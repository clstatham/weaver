// Ignored
WHITESPACE    = _{ " " | "\t" | NEWLINE }
COMMENT       = _{ line_comment | block_comment }
line_comment  = _{ "//" ~ (!NEWLINE ~ ANY)* }
block_comment = _{ "/*" ~ (block_comment | (!"*/" ~ ANY))* ~ "*/" }

// Tokens
period     = _{ "." }
comma      = _{ "," }
colon      = _{ ":" }
semi       = _{ ";" }
lparen     = _{ "(" }
rparen     = _{ ")" }
lbrack     = _{ "[" }
rbrack     = _{ "]" }
lbrace     = _{ "{" }
rbrace     = _{ "}" }
plus       =  { "+" }
minus      =  { "-" }
star       =  { "*" }
slash      =  { "/" }
percent    =  { "%" }
eq         =  { "=" }
plus_eq    =  { "+=" }
minus_eq   =  { "-=" }
star_eq    =  { "*=" }
slash_eq   =  { "/=" }
percent_eq =  { "%=" }
lt         =  { "<" }
gt         =  { ">" }
lte        =  { "<=" }
gte        =  { ">=" }
eqeq       =  { "==" }
neq        =  { "!=" }
and        =  { "&&" }
or         =  { "||" }
not        =  { "!" }
xor        =  { "^" }

// Literals

// string_literal = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
float_literal = @{ ASCII_DIGIT+ ~ period ~ ASCII_DIGIT+ }
int_literal   = @{ ASCII_DIGIT+ }
literal       = _{ float_literal | int_literal }

// Keywords
component  = _{ "component" }
system     = _{ "system" }
impl       = _{ "impl" }
func       = _{ "func" }
let        = _{ "let" }
var        = _{ "var" }
if         = _{ "if" }
else       =  { "else" }
elif       =  { "elif" }
loop       = _{ "loop" }
break      = _{ "break" }
query      = _{ "query" }
with       = _{ "with" }
without    = _{ "without" }
startup    = _{ "@startup" }
update     = _{ "@update" }
system_tag = @{ startup | update }
// attribute  = @{ startup | update }
// function   = @{ "print" | "spawn" }
// keyword    = @{ component | system | impl | func | let | var | if | else | elif | loop | break | query | with | without }

// Types
int               =  { "int" }
float             =  { "float" }
ident             = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }
capitalized_ident = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | ASCII_DIGIT | "_")* }
type              =  { int | float | capitalized_ident }
let_ident         =  { let ~ ident }
var_ident         =  { var ~ ident }
typed_ident       =  { ident ~ colon ~ type }
let_typed_ident   =  { let ~ ident ~ colon ~ type }
var_typed_ident   =  { var ~ ident ~ colon ~ type }

// Top level
program    = { SOI ~ statements ~ EOI }
statements = { statement* }

// Statements
block          = { lbrace ~ statements ~ rbrace }
statement      = { (component_stmt | system_stmt | func_stmt | impl_stmt | break_stmt | expr) ~ semi? }
component_stmt = { component ~ ident ~ lbrace ~ typed_ident* ~ rbrace }
system_stmt    = { system_tag? ~ system ~ capitalized_ident ~ block }

break_stmt     = { break ~ expr? }
func_stmt      = { func ~ ident ~ lparen ~ typed_args ~ rparen ~ block }
impl_stmt      = { impl ~ capitalized_ident ~ block }
typed_args     = { (typed_ident ~ comma)* ~ typed_ident? }
typed_decls    = { ((var_typed_ident | let_typed_ident) ~ comma)* ~ (var_typed_ident | let_typed_ident)? }
with_clause    = { with ~ lbrack ~ (type ~ comma)* ~ type? ~ rbrack }
without_clause = { without ~ lbrack ~ (type ~ comma)* ~ type? ~ rbrack }

// Expressions
prefix           = _{ minus | not }
infix            = _{ plus | minus | star | slash | percent | lte | gte | eqeq | neq | and | or | xor | lt | gt }
call_expr        =  { ident ~ lparen ~ (expr ~ comma)* ~ expr? ~ rparen }
member_expr      =  { ident ~ period ~ (call_expr | ident) }
assign_expr      =  { (member_expr | ident) ~ (plus_eq | minus_eq | star_eq | slash_eq | percent_eq | eq) ~ expr }
decl_expr        =  { (var_ident | let_ident) ~ eq ~ expr }
constructor_expr =  { type ~ lbrace ~ expr* ~ rbrace }
if_expr          =  { if ~ expr ~ block ~ (elif ~ expr ~ block)* ~ (else ~ block)? }
query_expr       =  { query ~ ident ~ lbrace ~ typed_decls ~ (with_clause | without_clause)* ~ rbrace }
loop_expr        =  { loop ~ expr? ~ block }
primary_expr     = _{ literal | query_expr | if_expr | loop_expr | constructor_expr | call_expr | decl_expr | assign_expr | member_expr | ident | block | (lparen ~ expr ~ rparen) }
expr             =  { primary_expr ~ (infix ~ prefix? ~ primary_expr)* }
