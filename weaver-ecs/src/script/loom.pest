// Ignored
WHITESPACE    = _{ " " | "\t" | NEWLINE }
COMMENT       = _{ line_comment | block_comment }
line_comment  = _{ "//" ~ (!NEWLINE ~ ANY)* }
block_comment = _{ "/*" ~ (block_comment | (!"*/" ~ ANY))* ~ "*/" }

// Tokens
period       = _{ "." }
comma        = _{ "," }
colon        = _{ ":" }
semi         = _{ ";" }
lparen       = _{ "(" }
rparen       = _{ ")" }
lbrack       = _{ "[" }
rbrack       = _{ "]" }
lbrace       = _{ "{" }
rbrace       = _{ "}" }
plus         =  { "+" }
minus        =  { "-" }
star         =  { "*" }
slash        =  { "/" }
percent      =  { "%" }
eq           =  { "=" }
plus_eq      =  { "+=" }
minus_eq     =  { "-=" }
star_eq      =  { "*=" }
slash_eq     =  { "/=" }
percent_eq   =  { "%=" }
lt           =  { "<" }
gt           =  { ">" }
lte          =  { "<=" }
gte          =  { ">=" }
eqeq         =  { "==" }
neq          =  { "!=" }
and          =  { "&&" }
or           =  { "||" }
not          =  { "!" }
xor          =  { "^" }
double_quote = _{ "\"" }
rarrow       = _{ "->" }

// Literals

string_literal = @{ double_quote ~ (!double_quote ~ ANY)* ~ double_quote }
float_literal  = @{ minus? ~ ASCII_DIGIT+ ~ period ~ ASCII_DIGIT+ }
int_literal    = @{ minus? ~ ASCII_DIGIT+ }
literal        = _{ float_literal | int_literal | string_literal }

// Keywords
component  = _{ "component" }
system     = _{ "system" }
impl       = _{ "impl" }
func       = _{ "func" }
let        = _{ "let" }
var        = _{ "var" }
if         = _{ "if" }
else       =  { "else" }
elif       =  { "elif" }
loop       = _{ "loop" }
break      = _{ "break" }
return     = _{ "return" }
query      = _{ "query" }
with       = _{ "with" }
without    = _{ "without" }
res        = _{ "res" }
startup    = _{ "@startup" }
update     = _{ "@update" }
system_tag = @{ startup | update }
// attribute  = @{ startup | update }
// function   = @{ "print" | "spawn" | "vec3" | "vec4" | "mat4" | "quat" }
// keyword    = @{ component | system | impl | func | let | var | if | else | elif | loop | break | query | with | without }

// Types
int               =  { "Int" }
float             =  { "Float" }
vec3              =  { "Vec3" }
quat              =  { "Quat" }
mat3              =  { "Mat3" }
mat4              =  { "Mat4" }
string            =  { "String" }
ident             = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }
capitalized_ident = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | ASCII_DIGIT | "_")* }
type              =  { int | float | vec3 | quat | mat3 | mat4 | string | capitalized_ident }
let_ident         =  { let ~ ident }
var_ident         =  { var ~ ident }
typed_ident       =  { ident ~ colon ~ type }
let_typed_ident   =  { let ~ ident ~ colon ~ type }
var_typed_ident   =  { var ~ ident ~ colon ~ type }

// Top level
program    = { SOI ~ statements ~ EOI }
statements = { statement* }

// Statements
block          = { lbrace ~ statements ~ rbrace }
statement      = { (component_stmt | system_stmt | func_stmt | impl_stmt | break_stmt | return_stmt | expr) ~ semi? }
component_stmt = { component ~ ident ~ lbrace ~ typed_ident* ~ rbrace }
system_stmt    = { system_tag? ~ system ~ ident ~ block }
break_stmt     = { break ~ expr? }
return_stmt    = { return ~ expr? }
func_stmt      = { func ~ ident ~ lparen ~ typed_args ~ rparen ~ (rarrow ~ type)? ~ block }
impl_stmt      = { impl ~ capitalized_ident ~ block }
typed_args     = { (typed_ident ~ comma)* ~ typed_ident? }
with_clause    = { with ~ lbrack ~ (type ~ comma)* ~ type? ~ rbrack }
without_clause = { without ~ lbrack ~ (type ~ comma)* ~ type? ~ rbrack }

// Expressions
prefix           = _{ minus | not }
infix            = _{ plus | minus | star | slash | percent | lte | gte | eqeq | neq | and | or | xor | lt | gt }
call_expr        =  { ident ~ lparen ~ (expr ~ comma)* ~ expr? ~ rparen }
member_expr      =  { (type | ident) ~ period ~ (call_expr | ident) ~ (period ~ (call_expr | ident))* }
assign_expr      =  { (member_expr | ident) ~ (plus_eq | minus_eq | star_eq | slash_eq | percent_eq | eq) ~ expr }
decl_expr        =  { (var_ident | let_ident) ~ eq ~ expr }
constructor_expr =  { type ~ lbrace ~ (ident ~ colon ~ expr ~ comma)* ~ (ident ~ colon ~ expr)? ~ rbrace }
if_expr          =  { if ~ expr ~ block ~ (elif ~ expr ~ block)* ~ (else ~ block)? }
query_expr       =  { query ~ ident ~ lbrack ~ typed_decls ~ ((with_clause | without_clause) ~ comma)* ~ (with_clause | without_clause)? ~ rbrack }
typed_decls      =  { ((var_typed_ident | let_typed_ident) ~ comma)* ~ (var_typed_ident | let_typed_ident)? }
var_res          =  { var ~ res ~ ident ~ colon ~ type }
let_res          =  { let ~ res ~ ident ~ colon ~ type }
loop_expr        =  { loop ~ expr? ~ block }
primary_expr     = _{ literal | query_expr | var_res | let_res | if_expr | loop_expr | constructor_expr | call_expr | decl_expr | assign_expr | member_expr | ident | block | (lparen ~ expr ~ rparen) }
expr             =  { primary_expr ~ (infix ~ prefix? ~ primary_expr)* }
